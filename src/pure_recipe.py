import argparse
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Optional

import platformdirs
import yaml
from recipe_scrapers import scrape_me
from rich.console import Console
from rich.markdown import Markdown

HOME_DIRECTORY: Path = Path(platformdirs.user_config_dir(), "pure-recipe")
CONFIG_PATH: Path = HOME_DIRECTORY / "config.yaml"
console = Console()


@dataclass
class Settings:
    """
    Represents the settings for the Pure Recipe application.

    Attributes:
        directory (Path): The directory where recipes are stored.
        show_time (bool): Flag indicating whether to display the time in recipes.
        show_yield (bool): Flag indicating whether to display the yield in recipes.
    """

    directory: Path
    show_time: bool
    show_yield: bool

    @staticmethod
    def from_yaml(yaml_path: Path):
        """
        Loads the settings from a YAML file.

        Args:
            yaml_path (Path): The path to the YAML file.

        Returns:
            Settings: The loaded settings.
        """
        with yaml_path.open() as f:
            yaml_settings = yaml.safe_load(f) or {}

        directory = yaml_settings.get("directory")
        if directory is None:
            directory = HOME_DIRECTORY / "recipes"
            directory.mkdir(parents=True, exist_ok=True)
        else:
            directory = Path(directory)

        show_time = yaml_settings.get("time")
        if show_time is None:
            show_time = True

        show_yield = yaml_settings.get("yield")
        if show_yield is None:
            show_yield = True

        return Settings(
            directory=directory,
            show_time=show_time,
            show_yield=show_yield,
        )

    def to_yaml(self, yaml_path: Path):
        """
        Saves the settings to a YAML file.

        Args:
            yaml_path (Path): The path to the YAML file.
        """
        yaml_path.write_text(
            yaml.safe_dump(
                {
                    "directory": self.directory.as_posix(),
                    "time": self.show_time,
                    "yield": self.show_yield,
                }
            )
        )


@dataclass
class PureRecipe:
    """
    Represents a pure recipe with title, ingredients, instructions, total time, and yield amount.
    """

    title: str
    ingredients: List[str]
    instructions: List[str]
    total_time: Optional[int]
    yield_amount: Optional[int]

    @property
    def filename(self) -> str:
        """
        Returns the filename for the recipe, generated by replacing spaces with hyphens and converting to lowercase.

        Returns:
            str: The filename for the recipe.
        """
        return self.title.replace(" ", "-").lower()

    @staticmethod
    def from_url(url: str, settings: Settings):
        """
        Creates a PureRecipe object by scraping the recipe from the given URL.

        Args:
            url (str): The URL of the recipe.
            settings (Settings): The settings object containing the configuration.

        Returns:
            PureRecipe: The scraped recipe.
        """
        scraper = scrape_me(url)

        additional_info = {}
        if settings.show_time:
            additional_info["total_time"] = scraper.total_time()
        if settings.show_yield:
            additional_info["yield_amount"] = scraper.yields()

        return PureRecipe(
            title=scraper.title(),
            ingredients=scraper.ingredients(),
            instructions=scraper.instructions_list(),
            **additional_info,
        )

    def to_markdown(self) -> Markdown:
        """
        Converts the recipe to Markdown format.

        Returns:
            Markdown: The Markdown representation of the recipe.
        """
        additional_info = []
        if self.yield_amount:
            additional_info.append(f"**Serves:** {self.yield_amount}")
        if self.total_time:
            additional_info.append(f"**Total Time:** {self.total_time} mins")

        ingredients_section = "\n".join(
            [f"- {ingredient}" for ingredient in self.ingredients]
        )

        instructions_section = "\n".join(
            [
                f"{index}. {instruction}"
                for index, instruction in enumerate(self.instructions, start=1)
            ]
        )

        return Markdown(
            "\n".join(
                [
                    f"# {self.title}",
                    "\n".join(additional_info),
                    "\n## Ingredients",
                    ingredients_section,
                    "\n## Instructions",
                    instructions_section,
                ]
            )
        )

    def print(self):
        """
        Prints the recipe to the console.
        """
        console.print("\n")
        console.print(self.to_markdown())
        console.print("\n")

    def dump(self, path: Path):
        """
        Dumps the recipe to a file.

        Args:
            path (Path): The path to the file.
        """
        path.write_text(self.to_markdown().markup)


class Resources:
    """
    A class that provides various resources for the pure-recipe application.
    """

    @dataclass
    class PrintLine:
        """
        A class representing a line of text to be printed.

        Attributes:
            text (str): The text to be printed.
            kwargs (dict): Additional keyword arguments for printing.
        """

        text: str
        kwargs: dict = field(default_factory=dict)

    USAGE_ERROR = [
        PrintLine("Uh oh! There was an error.", {"style": "bright_red bold"}),
        PrintLine("Usage:\t python pure-recipe.py {view|save|list|browse} [url|file]"),
        PrintLine("Try again, or see documentation for more info."),
    ]

    def print_printable_lines(self, printable_lines: List[PrintLine]) -> None:
        """
        Prints the given list of printable lines.

        Args:
            printable_lines (List[PrintLine]): The list of printable lines to be printed.
        """
        for line in printable_lines:
            console.print(line.text, **line.kwargs)


def get_recipe_title(filepath: Path) -> str:
    """
    Retrieves the title of a recipe from a file.

    Args:
        filepath (Path): The path to the recipe file.

    Returns:
        str: The title of the recipe.
    """
    with filepath.open() as f:
        title = f.readline().lstrip("#")
    return title


class PureRecipeApp:
    """
    The main application class for the Pure Recipe app.

    Attributes:
        settings (Settings): The settings for the app.
        ACTIONS (List[str]): The list of available actions.

    Methods:
        __init__(self, settings: Optional[Settings] = None): Initializes the PureRecipeApp instance.
        dispatch(self, actions, url): Dispatches the specified actions based on the given URL.
        view(self, url): View a recipe from the given URL.
        save(self, url): Saves a recipe from the given URL.
        list(self, url): Reads a file from the given URL and saves each line into the recipe database.
        recipes_scan(self): Scans the recipes directory and yields the title and file path of each recipe file.
        browse(self): Allows the user to browse and choose a recipe from a collection of recipes.
    """

    settings: Settings

    ACTIONS = ["view", "save", "list", "browse"]

    def __init__(self, settings: Optional[Settings] = None):
        if settings:
            self.settings = settings

    def dispatch(self, actions, url):
        """
        Dispatches the specified actions based on the given URL.

        Args:
            actions (str): The action to be performed.
            url (str): The URL to be processed.

        Raises:
            Exception: If an error occurs during the dispatch process.
        """
        try:
            if actions == "view":
                self.view(url)
            elif actions == "save":
                self.save(url)
            elif actions == "list":
                self.list(url)
            elif actions == "browse":
                self.browse()
        except Exception:
            Resources().print_printable_lines(Resources.USAGE_ERROR)

    def view(self, url):
        """
        View a recipe from the given URL.

        Args:
            url (str): The URL of the recipe.

        Returns:
            None
        """
        recipe = PureRecipe.from_url(url, self.settings)
        recipe.print()

    def save(self, url):
        """
        Saves a recipe from the given URL.

        Args:
            url (str): The URL of the recipe.

        Returns:
            None
        """
        recipe = PureRecipe.from_url(url, self.settings)
        recipe.dump(Path(self.settings.directory, f"{recipe.filename}.md"))

    def list(self, url):
        """
        Reads a file from the given URL and saves each line into the recipe database.

        Args:
            url (str): The URL of the file to be read.

        Returns:
            None
        """
        with Path(url).open() as file:
            for line in file:
                self.save(line.strip())

    def recipes_scan(self):
        """
        Scans the recipes directory and yields the title and file path of each recipe file.

        Returns:
            Generator: A generator that yields tuples containing the recipe title and file path.
        """
        recipes_directory: Path = Path(self.settings.directory).resolve()
        print(recipes_directory.as_posix())

        for recipe_file in recipes_directory.iterdir():
            if recipe_file.is_dir():
                continue
            if not recipe_file.name.endswith(".md"):
                continue

            recipe_title = get_recipe_title(recipe_file)
            yield recipe_title, recipe_file

    def browse(self):
        """
        Allows the user to browse and choose a recipe from a collection of recipes.
        The user can enter a number to choose a recipe or 'q' to quit.
        If the chosen recipe exists, it will be displayed in Markdown format.
        """
        recipes_collection = {
            "titles": {},
            "filepaths": {},
        }

        for index, (recipe_title, recipe_file) in enumerate(
            self.recipes_scan(), start=1
        ):
            recipes_collection["titles"][f"{index}"] = recipe_title
            recipes_collection["filepaths"][recipe_title] = recipe_file

        while True:
            for index, recipe_title in recipes_collection["titles"].items():
                console.print(f"({index}) {recipe_title}", style="green")

            inp = input("Enter a number to choose a recipe. Or, enter 'q' to quit.\n")

            if inp == "q":
                sys.exit()

            if inp in recipes_collection["filepaths"]:
                recipe_md = Markdown(recipes_collection["filepaths"][inp].read_text())
                console.print("\n")
                console.print(recipe_md)
                console.print("\n")
                continue

            if inp.isdigit() and inp not in recipes_collection["titles"]:
                console.print("\nInput error. Try again.\n", style="bright_red")
                continue

            recipe_title = recipes_collection["titles"].get(inp)

            if not recipe_title:
                console.print("\nInput error. Try again.\n", style="bright_red")
                continue

            recipe_md = Markdown(
                recipes_collection["filepaths"][recipe_title].read_text()
            )
            console.print("\n")
            console.print(recipe_md)
            console.print("\n")


def main():
    """
    Flow for the application.

    Depending on the arguments, we either view or save the corresponding recipe.

    Or, we can browse previously saved recipes.
    """
    HOME_DIRECTORY.mkdir(exist_ok=True, parents=True)
    CONFIG_PATH.touch(exist_ok=True)
    settings = Settings.from_yaml(CONFIG_PATH)
    pure_recipe_app = PureRecipeApp(settings=settings)
    settings.to_yaml(CONFIG_PATH)

    parser = argparse.ArgumentParser(
        prog="Pure Recipe", description="Make recipes pretty again."
    )
    parser.add_argument("operations", choices=PureRecipeApp.ACTIONS)
    parser.add_argument("url", default="foo", nargs="?")

    args = parser.parse_args()

    pure_recipe_app.dispatch(actions=args.operations, url=args.url)


if __name__ == "__main__":
    main()
